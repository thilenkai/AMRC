# Set global options for all code chunks
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, tidy = TRUE)
rmsep_results2 <- RMSEP(pls_model)
# Set global options for all code chunks
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, tidy = TRUE)
if (!requireNamespace("pls", quietly = TRUE)) {
install.packages("pls")
}
library(pls)
library(cvTools)
library(leaps)
# Load the dataset
load("building.RData")
#str(df)
set.seed(12332281)
# Split the data
sample_index <- sample(1:nrow(df), size = 2/3 * nrow(df))
train_data <- df[sample_index, ]
test_data <- df[-sample_index, ]
# Display the number of samples in each set
cat("Training set size:", nrow(train_data), "\n")
cat("Test set size:", nrow(test_data), "\n")
# Fit linear regression model
model <- lm(y ~ ., data = train_data)
# summary(model)
train_pred <- predict(model, newdata = train_data)
# Compute RMSE for training data
train_rmse <- sqrt(mean((train_data$y - train_pred)^2))
cat("Training RMSE:", train_rmse, "\n")
# Fit PCR model with cross-validation and scaling
pcr_model <- pcr(y ~ ., data = train_data, scale = TRUE,
validation = "CV", segments = 10)
summary(pcr_model)
# Plot cross-validation errors for each component
validationplot(pcr_model, val.type = "MSEP",
main = "PCR Cross-Validation Error Plot")
rmsep_results <- RMSEP(pcr_model)
rmsep_values <- rmsep_results$val
# Now you can find the optimal RMSE
optimal_components <- 68
optimal_rmse <- rmsep_values[optimal_components]
cat("Resulting RMSE at optimal components:", optimal_rmse, "\n")
# Plot measured vs cross-validated predictions
predplot(pcr_model, ncomp = optimal_components,
main = "Measured vs Cross-Validated Predictions")
test_pred <- predict(pcr_model, newdata = test_data, ncomp = 68)
# Plot Predicted vs Observed values for Test Data
plot(test_data$y, test_pred,
main = "Predicted vs Actual Response (Test Data)",
xlab = "Actual Response",
ylab = "Predicted Values",
pch = 16, col = "lightblue")
abline(0, 1, col = "red", lwd = 2)
# Calculate RMSE for Test Data
test_rmse <- sqrt(mean((test_data$y - test_pred)^2))
cat("Test RMSE:", test_rmse, "\n")
# Apply PLS on the training data with cross-validation and scaling
pls_model <- plsr(y ~ ., data = train_data, scale = TRUE,
validation = "CV", segments = 10)
summary(pls_model)
# Plot cross-validation errors for each component
validationplot(pls_model, val.type = "MSEP",
main = "PLS Cross-Validation Error Plot")
rmsep_results2 <- RMSEP(pls_model)
rmsep_values2 <- rmsep_results2$val
# Now you can find the optimal RMSE
optimal_components <- 67
optimal_rmse <- rmsep_values2[optimal_components]
cat("Resulting RMSE at optimal components:", optimal_rmse, "\n")
# Plot measured vs cross-validated predictions
predplot(pls_model, ncomp = optimal_components,
main = "Measured vs Cross-Validated Predictions")
pls_test_pred <- predict(pls_model, newdata = test_data, ncomp = 65)
# Plot Predicted vs Observed values for Test Data
plot(test_data$y, test_pred,
main = "Predicted vs Actual Response (Test Data)",
xlab = "Actual Response",
ylab = "Predicted Values",
pch = 16, col = "lightblue")
abline(0, 1, col = "red", lwd = 2)
# Calculate RMSE for test data predictions
pls_test_rmse <- sqrt(mean((test_data$y - pls_test_pred)^2))
cat("Test RMSE for PLS:", pls_test_rmse, "\n")
# Extract coefficients for the optimal number of components in PCR and PLS
pcr_coefs <- coef(pcr_model, ncomp = optimal_components)
pls_coefs <- coef(pls_model, ncomp = optimal_components)
# Convert to data frame for easy plotting
coef_data <- data.frame(
Predictor = rownames(pcr_coefs),
PCR = as.vector(pcr_coefs),
PLS = as.vector(pls_coefs)
)
# Plot the coefficients for PCR and PLS
library(ggplot2)
ggplot(coef_data, aes(x = Predictor)) +
geom_bar(aes(y = PCR, fill = "PCR"), stat = "identity", position = "dodge") +
geom_bar(aes(y = PLS, fill = "PLS"), stat = "identity", position = "dodge") +
labs(title = "Comparison of Regression Coefficients for PCR and PLS",
y = "Coefficient Value") +
scale_fill_manual(values = c("PCR" = "blue", "PLS" = "lightgreen")) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
theme_minimal()
library(ggplot2)
library(gridExtra)
# Extract scores and loadings for PCR
pcr_scores <- pcr_model$scores[, 1:2]  # First two score vectors (Z1 and Z2)
pcr_loadings <- pcr_model$loadings[, 1:2]  # First two loading vectors (V1 and V2)
# Extract scores and loadings for PLS
pls_scores <- pls_model$scores[, 1:2]  # First two score vectors (T1 and T2)
pls_loadings <- pls_model$loadings[, 1:2]  # First two loading vectors (W1 and W2)
# Convert to data frames for ggplot
pcr_scores_df <- as.data.frame(pcr_scores)
pcr_loadings_df <- as.data.frame(pcr_loadings)
pls_scores_df <- as.data.frame(pls_scores)
pls_loadings_df <- as.data.frame(pls_loadings)
# Plot PCR scores
p1 <- ggplot(pcr_scores_df, aes(x = `Comp 1`, y = `Comp 2`)) +
geom_point(color = "blue") +
labs(title = "PCR Scores (Z1 vs Z2)", x = "Z1", y = "Z2")
# Plot PCR loadings
p2 <- ggplot(pcr_loadings_df, aes(x = `Comp 1`, y = `Comp 2`)) +
geom_point(color = "red") +
labs(title = "PCR Loadings (V1 vs V2)", x = "V1", y = "V2")
# Plot PLS scores
p3 <- ggplot(pls_scores_df, aes(x = `Comp 1`, y = `Comp 2`)) +
geom_point(color = "green") +
labs(title = "PLS Scores (T1 vs T2)", x = "T1", y = "T2")
# Plot PLS loadings
p4 <- ggplot(pls_loadings_df, aes(x = `Comp 1`, y = `Comp 2`)) +
geom_point(color = "purple") +
labs(title = "PLS Loadings (W1 vs W2)", x = "W1", y = "W2")
# Arrange the plots in a 2x2 grid
grid.arrange(p1, p2, p3, p4, ncol = 2)
pls_test_pred <- predict(pls_model, newdata = test_data, ncomp = 67)
# Plot Predicted vs Observed values for Test Data
plot(test_data$y, test_pred,
main = "Predicted vs Actual Response (Test Data)",
xlab = "Actual Response",
ylab = "Predicted Values",
pch = 16, col = "lightblue")
abline(0, 1, col = "red", lwd = 2)
# Calculate RMSE for test data predictions
pls_test_rmse <- sqrt(mean((test_data$y - pls_test_pred)^2))
cat("Test RMSE for PLS:", pls_test_rmse, "\n")
pls_test_pred <- predict(pls_model, newdata = test_data, ncomp = 67)
# Plot Predicted vs Observed values for Test Data
plot(test_data$y, test_pred,
main = "Predicted vs Actual Response (Test Data)",
xlab = "Actual Response",
ylab = "Predicted Values",
pch = 16, col = "lightblue")
abline(0, 1, col = "red", lwd = 2)
# Calculate RMSE for test data predictions
pls_test_rmse <- sqrt(mean((test_data$y - pls_test_pred)^2))
cat("Test RMSE for PLS:", pls_test_rmse, "\n")
# Extract coefficients for the optimal number of components in PCR and PLS
pcr_coefs <- coef(pcr_model, ncomp = 68)
pls_coefs <- coef(pls_model, ncomp = 67)
# Convert to data frame for easy plotting
coef_data <- data.frame(
Predictor = rownames(pcr_coefs),
PCR = as.vector(pcr_coefs),
PLS = as.vector(pls_coefs)
)
# Plot the coefficients for PCR and PLS
library(ggplot2)
ggplot(coef_data, aes(x = Predictor)) +
geom_bar(aes(y = PCR, fill = "PCR"), stat = "identity", position = "dodge") +
geom_bar(aes(y = PLS, fill = "PLS"), stat = "identity", position = "dodge") +
labs(title = "Comparison of Regression Coefficients for PCR and PLS",
y = "Coefficient Value") +
scale_fill_manual(values = c("PCR" = "blue", "PLS" = "lightgreen")) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
theme_minimal()
rmsep_results2 <- RMSEP(pls_model)
rmsep_values2 <- rmsep_results2$val
# Now you can find the optimal RMSE
optimal_components <- 19
optimal_rmse <- rmsep_values2[optimal_components]
cat("Resulting RMSE at optimal components:", optimal_rmse, "\n")
# Plot measured vs cross-validated predictions
predplot(pls_model, ncomp = optimal_components,
main = "Measured vs Cross-Validated Predictions")
pls_test_pred <- predict(pls_model, newdata = test_data, ncomp = 19)
# Plot Predicted vs Observed values for Test Data
plot(test_data$y, test_pred,
main = "Predicted vs Actual Response (Test Data)",
xlab = "Actual Response",
ylab = "Predicted Values",
pch = 16, col = "lightblue")
abline(0, 1, col = "red", lwd = 2)
# Calculate RMSE for test data predictions
pls_test_rmse <- sqrt(mean((test_data$y - pls_test_pred)^2))
cat("Test RMSE for PLS:", pls_test_rmse, "\n")
rmsep_results2 <- RMSEP(pls_model)
rmsep_values2 <- rmsep_results2$val
# Now you can find the optimal RMSE
optimal_components <- 8
optimal_rmse <- rmsep_values2[optimal_components]
cat("Resulting RMSE at optimal components:", optimal_rmse, "\n")
# Extract coefficients for the optimal number of components in PCR and PLS
pcr_coefs <- coef(pcr_model, ncomp = 22)
pls_coefs <- coef(pls_model, ncomp = 16)
# Convert to data frame for easy plotting
coef_data <- data.frame(
Predictor = rownames(pcr_coefs),
PCR = as.vector(pcr_coefs),
PLS = as.vector(pls_coefs)
)
# Plot the coefficients for PCR and PLS
library(ggplot2)
ggplot(coef_data, aes(x = Predictor)) +
geom_bar(aes(y = PCR, fill = "PCR"), stat = "identity", position = "dodge") +
geom_bar(aes(y = PLS, fill = "PLS"), stat = "identity", position = "dodge") +
labs(title = "Comparison of Regression Coefficients for PCR and PLS",
y = "Coefficient Value") +
scale_fill_manual(values = c("PCR" = "blue", "PLS" = "lightgreen")) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
theme_minimal()
# Extract coefficients for the optimal number of components in PCR and PLS
pcr_coefs <- coef(pcr_model, ncomp = 68)
pls_coefs <- coef(pls_model, ncomp = 67)
# Convert to data frame for easy plotting
coef_data <- data.frame(
Predictor = rownames(pcr_coefs),
PCR = as.vector(pcr_coefs),
PLS = as.vector(pls_coefs)
)
# Plot the coefficients for PCR and PLS
library(ggplot2)
ggplot(coef_data, aes(x = Predictor)) +
geom_bar(aes(y = PCR, fill = "PCR"), stat = "identity", position = "dodge") +
geom_bar(aes(y = PLS, fill = "PLS"), stat = "identity", position = "dodge") +
labs(title = "Comparison of Regression Coefficients for PCR and PLS",
y = "Coefficient Value") +
scale_fill_manual(values = c("PCR" = "blue", "PLS" = "lightgreen")) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
theme_minimal()
rmsep_results <- RMSEP(pcr_model)
rmsep_values <- rmsep_results$val
# Now you can find the optimal RMSE
optimal_components <- 23
optimal_rmse <- rmsep_values[optimal_components]
cat("Resulting RMSE at optimal components:", optimal_rmse, "\n")
# Plot measured vs cross-validated predictions
predplot(pcr_model, ncomp = optimal_components,
main = "Measured vs Cross-Validated Predictions")
rmsep_results <- RMSEP(pcr_model)
rmsep_values <- rmsep_results$val
# Now you can find the optimal RMSE
optimal_components <- 35
optimal_rmse <- rmsep_values[optimal_components]
cat("Resulting RMSE at optimal components:", optimal_rmse, "\n")
# Plot measured vs cross-validated predictions
predplot(pcr_model, ncomp = optimal_components,
main = "Measured vs Cross-Validated Predictions")
test_pred <- predict(pcr_model, newdata = test_data, ncomp = optimal_components)
# Plot Predicted vs Observed values for Test Data
plot(test_data$y, test_pred,
main = "Predicted vs Actual Response (Test Data)",
xlab = "Actual Response",
ylab = "Predicted Values",
pch = 16, col = "lightblue")
abline(0, 1, col = "red", lwd = 2)
# Calculate RMSE for Test Data
test_rmse <- sqrt(mean((test_data$y - test_pred)^2))
cat("Test RMSE:", test_rmse, "\n")
# Set global options for all code chunks
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, tidy = TRUE)
if (!requireNamespace("pls", quietly = TRUE)) {
install.packages("pls")
}
library(pls)
library(cvTools)
library(leaps)
# Load the dataset
load("building.RData")
#str(df)
set.seed(12332281)
# Split the data
sample_index <- sample(1:nrow(df), size = 2/3 * nrow(df))
train_data <- df[sample_index, ]
test_data <- df[-sample_index, ]
# Display the number of samples in each set
cat("Training set size:", nrow(train_data), "\n")
cat("Test set size:", nrow(test_data), "\n")
# Fit linear regression model
model <- lm(y ~ ., data = train_data)
# summary(model)
train_pred <- predict(model, newdata = train_data)
# Compute RMSE for training data
train_rmse <- sqrt(mean((train_data$y - train_pred)^2))
cat("Training RMSE:", train_rmse, "\n")
# Fit PCR model with cross-validation and scaling
pcr_model <- pcr(y ~ ., data = train_data, scale = TRUE,
validation = "CV", segments = 10)
summary(pcr_model)
# Plot cross-validation errors for each component
validationplot(pcr_model, val.type = "MSEP",
main = "PCR Cross-Validation Error Plot")
rmsep_results <- RMSEP(pcr_model)
rmsep_values <- rmsep_results$val
# Now you can find the optimal RMSE
optimal_components <- 35
optimal_rmse <- rmsep_values[optimal_components]
cat("Resulting RMSE at optimal components:", optimal_rmse, "\n")
# Plot measured vs cross-validated predictions
predplot(pcr_model, ncomp = optimal_components,
main = "Measured vs Cross-Validated Predictions")
test_pred <- predict(pcr_model, newdata = test_data, ncomp = optimal_components)
# Plot Predicted vs Observed values for Test Data
plot(test_data$y, test_pred,
main = "Predicted vs Actual Response (Test Data)",
xlab = "Actual Response",
ylab = "Predicted Values",
pch = 16, col = "lightblue")
abline(0, 1, col = "red", lwd = 2)
# Calculate RMSE for Test Data
test_rmse <- sqrt(mean((test_data$y - test_pred)^2))
cat("Test RMSE:", test_rmse, "\n")
# Apply PLS on the training data with cross-validation and scaling
pls_model <- plsr(y ~ ., data = train_data, scale = TRUE,
validation = "CV", segments = 10)
summary(pls_model)
# Plot cross-validation errors for each component
validationplot(pls_model, val.type = "MSEP",
main = "PLS Cross-Validation Error Plot")
rmsep_results2 <- RMSEP(pls_model)
rmsep_values2 <- rmsep_results2$val
# Now you can find the optimal RMSE
optimal_components2 <- 19
optimal_rmse <- rmsep_values2[optimal_components]
cat("Resulting RMSE at optimal components:", optimal_rmse, "\n")
# Plot measured vs cross-validated predictions
predplot(pls_model, ncomp = optimal_components2,
main = "Measured vs Cross-Validated Predictions")
pls_test_pred <- predict(pls_model, newdata = test_data, ncomp = optimal_components2)
# Plot Predicted vs Observed values for Test Data
plot(test_data$y, test_pred,
main = "Predicted vs Actual Response (Test Data)",
xlab = "Actual Response",
ylab = "Predicted Values",
pch = 16, col = "lightblue")
abline(0, 1, col = "red", lwd = 2)
# Calculate RMSE for test data predictions
pls_test_rmse <- sqrt(mean((test_data$y - pls_test_pred)^2))
cat("Test RMSE for PLS:", pls_test_rmse, "\n")
# Extract coefficients for the optimal number of components in PCR and PLS
pcr_coefs <- coef(pcr_model, ncomp = optimal_components)
pls_coefs <- coef(pls_model, ncomp = optimal_components2)
# Convert to data frame for easy plotting
coef_data <- data.frame(
Predictor = rownames(pcr_coefs),
PCR = as.vector(pcr_coefs),
PLS = as.vector(pls_coefs)
)
# Plot the coefficients for PCR and PLS
library(ggplot2)
ggplot(coef_data, aes(x = Predictor)) +
geom_bar(aes(y = PCR, fill = "PCR"), stat = "identity", position = "dodge") +
geom_bar(aes(y = PLS, fill = "PLS"), stat = "identity", position = "dodge") +
labs(title = "Comparison of Regression Coefficients for PCR and PLS",
y = "Coefficient Value") +
scale_fill_manual(values = c("PCR" = "blue", "PLS" = "lightgreen")) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
theme_minimal()
library(ggplot2)
library(gridExtra)
# Extract scores and loadings for PCR
pcr_scores <- pcr_model$scores[, 1:2]  # First two score vectors (Z1 and Z2)
pcr_loadings <- pcr_model$loadings[, 1:2]  # First two loading vectors (V1 and V2)
# Extract scores and loadings for PLS
pls_scores <- pls_model$scores[, 1:2]  # First two score vectors (T1 and T2)
pls_loadings <- pls_model$loadings[, 1:2]  # First two loading vectors (W1 and W2)
# Convert to data frames for ggplot
pcr_scores_df <- as.data.frame(pcr_scores)
pcr_loadings_df <- as.data.frame(pcr_loadings)
pls_scores_df <- as.data.frame(pls_scores)
pls_loadings_df <- as.data.frame(pls_loadings)
# Plot PCR scores
p1 <- ggplot(pcr_scores_df, aes(x = `Comp 1`, y = `Comp 2`)) +
geom_point(color = "blue") +
labs(title = "PCR Scores (Z1 vs Z2)", x = "Z1", y = "Z2")
# Plot PCR loadings
p2 <- ggplot(pcr_loadings_df, aes(x = `Comp 1`, y = `Comp 2`)) +
geom_point(color = "red") +
labs(title = "PCR Loadings (V1 vs V2)", x = "V1", y = "V2")
# Plot PLS scores
p3 <- ggplot(pls_scores_df, aes(x = `Comp 1`, y = `Comp 2`)) +
geom_point(color = "green") +
labs(title = "PLS Scores (T1 vs T2)", x = "T1", y = "T2")
# Plot PLS loadings
p4 <- ggplot(pls_loadings_df, aes(x = `Comp 1`, y = `Comp 2`)) +
geom_point(color = "purple") +
labs(title = "PLS Loadings (W1 vs W2)", x = "W1", y = "W2")
# Arrange the plots in a 2x2 grid
grid.arrange(p1, p2, p3, p4, ncol = 2)
# Extract coefficients for the optimal number of components in PCR and PLS
pcr_coefs <- coef(pcr_model, ncomp = optimal_components)
pls_coefs <- coef(pls_model, ncomp = optimal_components2)
# Convert to data frame for easy plotting
coef_data <- data.frame(
Predictor = rownames(pcr_coefs),
PCR = as.vector(pcr_coefs),
PLS = as.vector(pls_coefs)
)
# Plot the coefficients for PCR and PLS
library(ggplot2)
ggplot(coef_data, aes(x = Predictor)) +
geom_bar(aes(y = PCR, fill = "PCR"), stat = "identity", position = "dodge") +
geom_bar(aes(y = PLS, fill = "PLS"), stat = "identity", position = "dodge") +
labs(title = "Comparison of Regression Coefficients for PCR and PLS",
y = "Coefficient Value") +
scale_fill_manual(values = c("PCR" = "blue", "PLS" = "lightgreen")) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
theme_minimal()
